- name: init
  hosts: all
  any_errors_fatal: true
  pre_tasks:
    - name: import check Ansible version task
      import_tasks: utils/assert-ansible-version.yaml

    - name: check that this playbook is run against exactly two hosts
      assert:
        that: ansible_play_hosts | length == 2
        fail_msg: You must limit this playbook to two hosts.
        quiet: yes

    - name: check that ansible_limit contains exactly one comma
      assert:
        that: ansible_limit is match('^[^,]+,[^,]+$')
        fail_msg: Please use the --limit option with one comma.
        quiet: yes

    # TODO: confirmation
  tasks:
    - name: set source and destination host name
      set_fact:
        src_host: "{{ ansible_limit | regex_replace('(.+),.+', '\\1') }}"
        dest_host: "{{ ansible_limit | regex_replace('.+,(.+)', '\\1') }}"

- name: download DB
  hosts: all    # Can't use a variable here, so put everything in a block and limit with "when"
  tasks:
    - name: download DB on source host only
      block:
        - name: backup
          include_role:
            name: db
            tasks_from: backup

        - name: download
          include_role:
            name: db
            tasks_from: download

        - name: convert dump_name to path
          set_fact:
            dump_name: "{{ inventory_hostname }}/{{ dump_name }}"
      when: inventory_hostname == src_host

- name: copy and import the dump
  hosts: all
  tasks:
    - name: copy and import the dump on destination host only
      block:
        - name: create dump upload tempfile
          tempfile:
            prefix: db_dump.
          register: temp_dump

        - name: upload dump
          copy:
            src: "{{ hostvars[src_host].dump_name }}"  # dump_name variable is set in src_host only
            dest: "{{ temp_dump.path }}"
            force: yes    # overwrite empty temp_dump

        - name: create a backup before importing
          include_role:
            name: db
            tasks_from: backup

        - name: import the dump
          block:
            - name: run pg_restore
              command:
                argv:
                  - pg_restore
                  - --dbname={{ project_name }}
                  - --clean
                  - --if-exists
                  - --no-owner
                  - --no-acl
                  - --jobs=2
                  - "{{ temp_dump.path }}"
              register: pg_restore_result
          rescue:
            - name: Skip version printing
              fail:
                msg: Failed (see above)
                  # when: ... dump_name_initially_blank    TODO
              when: >
                  'could not open input file' in pg_restore_result.stderr

            - name: get source version
              command: pg_dump -V
              delegate_to: "{{ src_host }}"
              changed_when: false
              register: src_version

            - name: get destination version
              command: pg_restore -V
              changed_when: false
              register: dest_version

            - name: fail, printing versions
              fail:
                msg: |
                  pg_restore failed (see above)
                  FYI, source has "{{ src_version.stdout }}" and destination has "{{ dest_version.stdout }}"

      always:
        - name: remove dump tempfile
          file:
            path: "{{ temp_dump.path }}"
            state: absent

      when: inventory_hostname == dest_host
